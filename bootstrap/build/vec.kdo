type Vec<T> = struct {
    capacity: usize,
    length: usize,
    elements: &T
}

fn Vec_new() -> Vec<T> {
    let vec: Vec<T>;
    vec.capacity = 0usize;
    vec.length = 0usize;
    vec.elements = NULL;
    return vec;
}

fn Vec_push(vec: &Vec, element: &any) {
    if vec.length >= vec.capacity {
        vec.capacity = (vec.capacity + 1usize) * 2usize;
        vec.elements = realloc(vec.elements, (vec.capacity) * 8usize);
    };
    *__offset(vec.elements, vec.length) = element;
    vec.length = vec.length + 1usize;
}

fn Vec_get(vec: &Vec, index: usize) -> &any {
    return __offset(vec.elements, index);
}

fn Vec_iter(vec: &Vec) -> VecIter {
    let iter: VecIter;
    iter.vec = vec;
    iter.index = 0usize;    
    return iter;
}

type VecIter = struct {
    vec: &Vec,
    index: usize
}

fn VecIter_next(iter: &VecIter, out_element: &&any) -> bool {
    if iter.vec.length > iter.index {
        *out_element = __offset(iter.vec.elements, iter.index);
        iter.index = iter.index + 1usize;
        return true;
    };
    *out_element = NULL;
    return false;
}